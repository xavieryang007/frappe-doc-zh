# 虚拟文档字段

虚拟文档字段是给定文档（或记录）的动态属性。它是一个计算属性，不存储在站点数据库中。可用于表示可能是其他静态文档属性函数的数值。

## 如何使用虚拟文档字段

实现此功能涉及的步骤如下：

### 1. 定义虚拟文档字段

定义虚拟文档字段相当直接。只需在文档字段配置中勾选"虚拟"复选框即可。虚拟文档字段不会在文档类型的表中创建相应的列。这使得该字段在表单视图中为"只读"。

> 注意：除非您清楚操作，否则请避免将现有文档字段设为虚拟字段。

### 2. 为字段定义数据源

第一步仅为值添加了一个占位符。如果不添加规定字段应显示内容的代码，则字段本身不存在。有两种方法可以实现：

#### 通过扩展文档类型控制器

添加一个与虚拟字段同名的Python属性即可实现。这是最灵活的方式；您可以链接内部API请求，或从多个数据源获取数据，可能性无限。

```python
class Person(Document):
    @property
    def age(self):
        return frappe.utils.now_datetime() - self.creation
```

#### 使用文档字段的 `options` 属性

这种方式限制较多，因为它允许您直接从工作台编写代码。允许使用服务器脚本中的工具，并通过此方式访问文档属性。上述属性的等效写法可能如下：

```python
frappe.utils.now_datetime() - self.creation
```

上面提到的 `Person.full_name` 示例使用Python的f-string功能以类似方式实现。

> 注意：对于相对较小的脚本，应优先使用此方法。使用时注意不兼容类型错误。

## 对内部机制的影响

如果您熟悉Frappe框架的内部原理，此功能的表现会相当可预测。

### 后端API
`DatabaseQuery` 方法或数据库API不会返回虚拟值，因为它们不存在于站点数据库中。

### REST API
`/api/method/frappe.desk.form.load.getdoc` 和 `/api/resource` API使用 `Document.get_valid_dict`，它也会计算虚拟值。这些API也用于渲染工作台表单视图。

### 数据库
虚拟字段在相应文档类型的表中没有痕迹。但您可以在存储文档类型元数据的自定义字段、文档字段表中找到对应的记录，作为其存在的证据。

## 非虚拟文档类型上的虚拟表

> 注意：此功能仅在nightly（v16）版本中可用。此功能被视为实验性功能。

虚拟子表是一种在运行时计算的"表格"类型的虚拟字段。它在许多方面表现得像普通子表：

- 虚拟子表显示在父文档下的表单（网格）中。
- 其行是动态计算的（例如，通过缓存属性或描述符）。
- 它是只读的（无法通过常规ORM方法写入）。
- 父文档类型不持久化这些子行；它们仅存在于内存中。
- 虚拟表的描述符方法可以返回原始字典或文档实例。
- 从数据库加载时，会触发虚拟子表的描述符以填充子行。

虚拟表适用于显示计算/聚合数据或存储在其他地方的相关数据摘要。

### 定义虚拟子表

要定义虚拟子表，您需要在父文档类型中添加一个新字段条目，并将 `is_virtual` 设置为1。动态获取虚拟表的逻辑必须在文档类型控制器上定义为缓存属性。

注意：对于虚拟表，**绝不能**使用 `@property`，仅支持 `@cached_property` 和其他等效的非数据描述符。

```python
class User(…):
    # 这是一个缓存属性（或非数据描述符），返回计算出的行
    @cached_property
    def virtual_sessions(self):
        # 返回字典列表或文档实例列表
        sessions = get_session_logs(self.name)
        return sessions
```

在此示例中，当加载用户记录时，框架调用 `User.virtual_sessions` 来获取子行，然后在表单上下文中初始化一个名为 `virtual_sessions` 的虚拟子表。