# 查询构建器 (Query Builder)

`frappe.qb` 是一个基于 PyPika 编写的查询构建器，旨在为跨数据库查询提供统一的接口。

## 为什么使用查询构建器？

在开发应用时，经常需要从数据库检索特定数据。传统方法是使用 `frappe.db.sql` 编写原始 SQL 查询，例如：

```python
result = frappe.db.sql(
    f"""
    SELECT `path`,
    COUNT(*) as count,
    COUNT(CASE WHEN CAST(`is_unique` as Integer) = 1 THEN 1 END) as unique_count
    FROM `tabWeb Page View`
    WHERE `creation` BETWEEN {some_date} AND {some_later_date}
    """
)
```

查询构建器提供了一种更 Pythonic 的方式构建 SQL 查询，同时不失灵活性。上述查询用查询构建器可改写为：

```python
import frappe
from frappe.query_builder import DocType
from frappe.query_builder.functions import Count
from pypika.terms import Case

WebPageView = DocType("Web Page View")
count_all = Count('*').as_("count")
case = Case().when(WebPageView.is_unique == "1", "1")
count_is_unique = Count(case).as_("unique_count")

result = (
    frappe.qb.from_(WebPageView)
    .select(WebPageView.path, count_all, count_is_unique)
    .where(WebPageView.creation[some_date:some_later_date])
).run()
```

---

## frappe.qb 核心方法

### `frappe.qb.from_(doctype)`

构建 SELECT 查询，用于选择数据。

**示例：**
```python
query = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')
```
生成的 SQL：
```sql
SELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer`
```

**复杂示例：**
```python
customers = frappe.qb.DocType('Customer')
q = (
    frappe.qb.from_(customers)
    .select(customers.id, customers.fname, customers.lname, customers.phone)
    .where((customers.fname == 'Max') | (customers.id.like('RA%')))
    .where(customers.lname == 'Mustermann')
)
```
生成的 SQL：
```sql
SELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer` WHERE (`fname`='Max' OR `id` LIKE 'RA%') AND `lname`='Mustermann'
```

**注意：**
- 使用 `frappe.qb.DocType` 创建表引用。
- `select()` 可接受多个字段。
- 使用 `|` 表示 OR，`&` 表示 AND。
- 链式调用 `where()` 默认使用 AND 连接。

### `frappe.qb.DocType(name_of_table)`

返回一个 PyPika 表对象，自动添加 `tab` 前缀（如需要）。

### `frappe.qb.Table(name_of_table)`

与 `DocType` 类似，但不自动添加 `tab` 前缀，适用于如 `__Auth` 类的表。

### `frappe.qb.Field(name_of_column)`

返回一个 PyPika 字段对象，用于表示列，常用于列与值的比较。

**示例：**
```python
lname = frappe.qb.Field("lname")
q = frappe.qb.from_("customers").select("*").where(lname == 'Mustermann')
```

---

## 执行查询

### 转换为 SQL 字符串

使用 `str()` 或 `.get_sql()` 方法查看生成的 SQL：

```python
query = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')
str(query)  # 或 query.get_sql()
```

### 参数化查询与 `walk()` 方法

查询构建器默认对查询进行参数化，以防止 SQL 注入。使用 `walk()` 查看参数化后的查询及参数字典：

```python
doctype = frappe.qb.DocType("DocType")
frappe.qb.from_(doctype).select('*').where(doctype.name == "somename").walk()
# 输出：('SELECT * FROM `tabDocType` WHERE `name`=%(param1)s', {'param1': 'somename'})
```

### 使用 `run()` 执行查询

推荐使用 `run()` 方法执行查询，它支持所有 `frappe.db.sql` 的选项：

```python
frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone').run()
```

**示例选项：**
- `debug=True`：显示执行的 SQL 及耗时。
- `as_dict=True`：返回字典形式的结果。

### 直接使用 `frappe.db.sql`

也可以将查询对象直接传递给 `frappe.db.sql`，但会忽略权限检查和参数化。

```python
query = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')
frappe.db.sql(query)
```

---

## 函数模块：frappe.query_builder.functions

该模块提供常用函数，如 `Count`、`Sum` 等。

### 简单函数示例

计算 Notes 表中所有条目数：

```python
from frappe.query_builder.functions import Count

Notes = frappe.qb.DocType("Notes")
count_pages = Count(Notes.content).as_("Pages")
result = frappe.qb.from_(Notes).select(count_pages).run(as_dict=True)
```

### 自定义函数

使用 PyPika 的 `CustomFunction` 创建自定义函数：

```python
from pypika import CustomFunction

DateDiff = CustomFunction('DATE_DIFF', ['interval', 'start_date', 'end_date'])
q = Query.from_(customers).select(
    DateDiff('day', customers.created_date, customers.updated_date)
)
```

### 常数列

使用 `ConstantColumn` 创建带常量值的伪列：

```python
from frappe.query_builder.custom import ConstantColumn

frappe.qb.from_("DocType").select("name", ConstantColumn("john").as_("user"))
# 生成：SELECT `name`,'john' `user` FROM `tabDocType`
```

---

## 高级用法

### 特殊函数（如 MATCH AGAINST）

对于需要链式调用的特殊函数（如 MySQL 的 `MATCH ... AGAINST`），需继承 `DistinctOptionFunction` 并重写相应方法。

**示例 MATCH 类：**
```python
from pypika.functions import DistinctOptionFunction
from pypika.utils import builder

class MATCH(DistinctOptionFunction):
    def __init__(self, column: str, *args):
        super(MATCH, self).__init__(" MATCH", column, *args)
        self._Against = False

    def get_function_sql(self, **kwargs):
        s = super(DistinctOptionFunction, self).get_function_sql(**kwargs)
        if self._Against:
            return f"{s} AGAINST (f'+{self._Against}*') IN BOOLEAN MODE)"
        return s

    @builder
    def Against(self, text: str):
        self._Against = text
```

**使用：**
```python
from frappe.query_builder.functions import Match

match = Match("Column name").Against("Some_text_match")
# 生成：MATCH('Column name') AGAINST ('+Some_text_match*' IN BOOLEAN MODE)
```

### 跨数据库函数映射（ImportMapper）

当不同数据库有相同功能的函数时，使用 `ImportMapper` 根据数据库类型映射对应函数。

**示例（GroupConcat）：**
```python
from frappe.query_builder.utils import ImportMapper, db_type_is
from frappe.query_builder.custom import GROUP_CONCAT, STRING_AGG

GroupConcat = ImportMapper(
    {
        db_type_is.MARIADB: GROUP_CONCAT,
        db_type_is.POSTGRES: STRING_AGG
    }
)
```

---

## 总结

Frappe 查询构建器提供了一种安全、灵活且 Pythonic 的方式来构建数据库查询，支持多种数据库，并内置了大量常用函数和高级特性。通过链式调用，可以轻松构建复杂查询，同时保持代码清晰和安全。

如果有具体使用场景或问题，可以进一步参考 [PyPika 文档](https://github.com/kayak/pypika) 或 Frappe 官方文档。