# 10.21 缓存

本文档详细介绍了Frappe框架中的缓存技术，包括缓存策略、配置和优化方法。

## 概述

Frappe Framework内置了基于Redis的缓存机制，旨在提升应用性能，特别是减少重复计算和数据库查询。

## 1. 核心缓存策略

Frappe主要支持以下几种缓存策略：

### 1.1 键值对缓存
最基础的策略，用于存储简单的字符串或序列化后的对象。

**示例代码**：
```python
# 设置缓存
frappe.cache.set_value("key", "value")

# 获取缓存
value = frappe.cache.get_value("key")
```

### 1.2 哈希缓存
适用于存储具有多个字段的复杂对象（如用户信息），可以独立更新单个字段。

**示例代码**：
```python
# 设置哈希字段
frappe.cache.hset("user|admin", "name", "Admin")

# 获取所有哈希字段
user_data = frappe.cache.hgetall("user|admin")
```

### 1.3 文档缓存
Framework提供的便捷方法，用于缓存整个DocType文档，适合不常变动的数据（如系统设置）。

**示例代码**：
```python
# 获取缓存文档
system_settings = frappe.get_cached_doc("System Settings")
```

**自动失效**：当通过ORM（如 `doc.save()`）修改文档时，框架会尝试自动清除相关缓存。对于直接数据库操作，需手动清除。

### 1.4 函数结果缓存
通过 `@redis_cache` 装饰器自动缓存函数返回值，非常适合包装耗时的计算函数。

**示例代码**：
```python
from frappe.utils.caching import redis_cache

@redis_cache
def expensive_function(param1, param2):
    # 耗时计算逻辑
    return result
```

## 2. 缓存配置

### 2.1 Redis服务
Frappe的Bench工具会自动安装和配置Redis服务器。

### 2.2 配置文件
Redis配置位于Bench目录下的 `config/redis_cache.conf`。

### 2.3 关键配置参数

| 参数名 | 描述 | 默认值 | 建议值 |
|--------|------|--------|--------|
| `maxmemory` | Redis实例可使用的最大内存 | 737MB | 根据服务器资源调整 |
| `maxmemory-policy` | 内存不足时的淘汰策略 | `allkeys-lru` | 保持默认 |
| `port` | Redis服务端口 | 13000 | 保持默认 |

### 2.4 进程管理
通过Bench的Procfile和Supervisor来管理Redis服务的启动和停止。

## 3. 缓存优化与失效方法

为了避免数据陈旧，提供了明确的缓存失效策略。

### 3.1 设置过期时间
在写入缓存时指定生存时间，让其自动过期。

**示例代码**：
```python
# 设置1小时后过期
frappe.cache.set_value(key, result, expires_in_sec=60*60)

# 装饰器设置60秒TTL
@redis_cache(ttl=60)
def cached_function():
    return result
```

### 3.2 手动清除缓存

**清除键值缓存**：
```python
frappe.cache.delete_value(key)
```

**清除哈希字段**：
```python
frappe.cache.hdel(key, field)
```

**清除文档缓存**：
```python
frappe.clear_document_cache(doctype, name)
```

**清除函数缓存**：
```python
# 调用被装饰函数的clear_cache方法
expensive_function.clear_cache()
```

## 4. 高级实现细节

### 4.1 多租户支持
`frappe.cache` 会自动为缓存键添加站点前缀，因此同一Bench上的不同站点的缓存是隔离的，无需担心冲突。

### 4.2 序列化
Frappe使用Python的 `pickle` 模块处理复杂对象（如文档），开发者无需关心序列化细节。

### 4.3 客户端缓存
Framework在 `frappe.local.cache` 层面实现了请求/作业内的客户端缓存，避免在同一上下文中重复访问Redis。

## 5. 缓存使用场景

### 5.1 数据库查询结果缓存
```python
@redis_cache
def get_user_stats(user_id):
    return frappe.db.sql("""
        SELECT COUNT(*) as count 
        FROM `tabUser` 
        WHERE name = %s
    """, user_id, as_dict=True)[0]
```

### 5.2 配置信息缓存
```python
def get_system_config():
    config = frappe.cache.get_value("system_config")
    if not config:
        config = frappe.get_single("System Settings")
        frappe.cache.set_value("system_config", config, expires_in_sec=3600)
    return config
```

### 5.3 报表数据缓存
```python
@redis_cache(ttl=300)  # 5分钟缓存
def generate_sales_report(start_date, end_date):
    # 生成复杂的报表数据
    return report_data
```

## 6. 性能监控

### 6.1 缓存命中率监控
```python
# 监控缓存命中率
hit_count = frappe.cache.get_hit_count()
miss_count = frappe.cache.get_miss_count()
hit_rate = hit_count / (hit_count + miss_count) if (hit_count + miss_count) > 0 else 0
```

### 6.2 内存使用监控
```bash
# 查看Redis内存使用情况
redis-cli -p 13000 info memory
```

## 7. 最佳实践

### 7.1 策略选择
根据数据类型选择最合适的缓存策略：
- 简单值：键值对缓存
- 复杂对象：哈希或文档缓存
- 计算结果：函数装饰器缓存

### 7.2 关键优化
合理设置 `maxmemory` 并依赖LRU策略管理内存。对于不要求绝对实时性的数据，使用TTL自动过期是简单有效的办法。

### 7.3 失效纪律
对绕过ORM的数据修改，务必建立严格的手动缓存失效机制，这是保证数据一致性的关键。

### 7.4 缓存键设计
```python
# 好的缓存键设计
cache_key = f"user_profile:{user_id}:{lang}"

# 避免的缓存键设计
cache_key = "user_data"  # 太泛化
```

## 8. 故障排除

### 8.1 常见问题

**缓存不生效**：
- 检查Redis服务是否正常运行
- 验证缓存键是否正确
- 确认缓存策略是否适用

**内存不足**：
- 调整 `maxmemory` 配置
- 优化缓存策略和TTL设置
- 清理不必要的缓存数据

### 8.2 调试工具

```python
# 调试缓存操作
import frappe.utils.caching

# 查看缓存统计
print(frappe.cache.get_stats())

# 清空特定模式缓存
frappe.cache.delete_keys("user:*")
```

## 9. 相关命令

```bash
# 查看缓存状态
bench --site [site-name] redis-cli info

# 清空缓存
bench --site [site-name] clear-cache

# 监控缓存性能
bench --site [site-name] redis-cli monitor
```

---

原始链接: https://docs.frappe.io/framework/user/en/guides/caching